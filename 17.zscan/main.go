package main

import(
	"encoding/json"
	"crypto/tls"
	"io/ioutil"
	"net/http"
	_"reflect"
	"bufio"
	"strings"
	"regexp"
	"sync"
	"time"
	"fmt"
	"os"

	_"golang.org/x/text/transform"
	"golang.org/x/text/encoding"
	"golang.org/x/text/encoding/unicode"
	"golang.org/x/net/html/charset"
	"github.com/xioxu/gorandomua"

)


type Autogenerated []struct {
	RuleID         string `json:"rule_id"`
	Level          string `json:"level"`
	Softhard       string `json:"softhard"`
	Product        string `json:"product"`
	Company        string `json:"company"`
	Category       string `json:"category"`
	ParentCategory string `json:"parent_category"`
	Rules          [][]struct {
		Match   string `json:"match"`
		Content string `json:"content"`
	} `json:"rules"`
}


type Rules [][]struct {
	Match   string `json:"match"`
	Content string `json:"content"`
} 

type Rule []struct {
	Match   string `json:"match"`
	Content string `json:"content"`
} 

type Requests struct {
	Host		   string       
	Product        string   
	HttpHeader     string 
	HttpBody       string  
	HttpCert       string  
	Rules          Rules
}


var(
	threads  int 
	istrue   bool
)


func main() {
	//设置
	threads = 200
	urllist,number, _ := readLines("test.txt")
	fmt.Println("扫描数量",number)
	fmt.Println("扫描线程",threads)
	readJson("fofa.json",urllist)
}


func readLines(path string) ([]string, int, error) {
  file, err := os.Open(path)
  if err != nil {
    return nil,0, err
  }
  defer file.Close()

  var lines []string
  linecount :=0
  scanner := bufio.NewScanner(file)
  for scanner.Scan() {
    lines = append(lines, scanner.Text())
    linecount++
  }
  return lines,linecount,scanner.Err()
}


func readJson(path string, urllist []string) {
	file, err := os.Open(path)
	if err != nil {
		os.Exit(0)
  	}
  	defer file.Close()
    content, err := ioutil.ReadAll(file)
    var gobyjson Autogenerated
    errs := json.Unmarshal(content, &gobyjson)
    if errs != nil {
		fmt.Println("json 处理错误 ！")
		os.Exit(0)
	}


	informations := make(chan Requests, threads)
	var wg sync.WaitGroup


	for i := 0; i < cap(informations); i++ {
		go worker(informations, &wg)
	}

	for _,v := range urllist {
		// 应该是先处理了数据，然后再弄
		HttpHeader,HttpBody,certss,_ := HttpGet(v)
		for _,goby:= range gobyjson {
			wg.Add(1)
			informations <-  Requests{Host: v,Product: goby.Product,HttpHeader:HttpHeader,HttpBody:HttpBody,HttpCert:certss,Rules: goby.Rules}
		}
	}
	wg.Wait()
	close(informations)
}


func worker(informations chan Requests, wg *sync.WaitGroup) {
	time.Sleep(2 * time.Second)
	for v := range informations {
		//fmt.Println(v.Host,v.Product,v.Rules)
		startscan(v.Host,v.Product,v.HttpHeader,v.HttpBody,v.HttpCert,v.Rules)
		wg.Done()
	}
}


func startscan(url string, product string,HttpHeader string ,HttpBody string,HttpCert string, rules Rules) {

	//HttpHeader,HttpBody,_ := HttpGet(url)
	/*
	1. 全部命中为 正式指纹，这玩意误报率还是挺高的
	2. 共有 number+1 个 为true减一，若是为0 证明为真
	*/
	var numbers  int
	numbers = len(rules)
	//fmt.Println(rules)
	for _,rule := range rules {
		switch rule[0].Match {
			case "body_contains" :
				if strings.Contains(strings.ToLower(HttpBody), strings.ToLower(rule[0].Content)) { numbers = numbers -1 }
			case "header_contains":
				if strings.Contains(strings.ToLower(HttpHeader), strings.ToLower(rule[0].Content)) { numbers = numbers -1 }
			case "title_contains":
				reTitle := regexp.MustCompile(`(?is)<title>\s?(.*?)\s?</title>`)
				if strings.Contains(strings.ToLower(reTitle.FindString(HttpBody)), strings.ToLower(rule[0].Content)) { numbers = numbers -1 }
			case "banner_contains":
				// 这个不精确
				if strings.Contains(strings.ToLower(HttpHeader), strings.ToLower(rule[0].Content)) { numbers = numbers -1 }
			case "server_contains":
				// 这个不精确
				if strings.Contains(strings.ToLower(HttpHeader), strings.ToLower(rule[0].Content)) { numbers = numbers -1 }
			case "cert_contains":
				if strings.Contains(strings.ToLower(HttpCert), strings.ToLower(rule[0].Content)) { numbers = numbers -1 }
		}
		if numbers == 0 {
			fmt.Println(url+"指纹为："+product)
			break
		}
	}
}



func determineEncoding(r *bufio.Reader) encoding.Encoding {
	b, err := r.Peek(1024)
	if err != nil {
		return unicode.UTF8
	}
	e, _, _ := charset.DetermineEncoding(b, "")
	return e
}


func HttpGet(url string) (Headers,Body,certss string, istrue bool ) {
	transCfg := &http.Transport{
		TLSClientConfig: &tls.Config{InsecureSkipVerify: true}, 
	}
	// 超时
	Client := &http.Client{
		Timeout:   10 * time.Second,
		Transport: transCfg,
	}
	req, err := http.NewRequest("GET", url, nil)

	if err != nil {
		//fmt.Println("http 请求错误 ！")
		// 日志输出错误
		return "","","",false
	}
	req.Header.Add("User-Agent", gorandomua.GetRandom())
	resp, err2 := Client.Do(req)
	if err2 != nil {
		return "","","",false
	}
	defer resp.Body.Close()
	// 获取证书信息
	var certs []byte
	var str string
	if resp.TLS != nil {
		cert := resp.TLS.PeerCertificates[0]
		//    var o []string
		//    o = append(o,cert.Subject.Organization...)
		if js, err := json.Marshal(cert); err == nil {
			//    b := regexp.MustCompile("(?i)123California\"]").MatchString(string(js))
			certs = js
		}
		str = string(certs) + cert.Issuer.String() + cert.Subject.String()
	}

	// 获取body信息
	bytes, _ := ioutil.ReadAll(resp.Body)
	respBody  := string(bytes)
	// 获取header信息
	var respHeader string
	for k, v := range resp.Header {
		respHeader += fmt.Sprintf("%v: %v\n", k, v[0])
	}
	return respHeader,respBody,str,true
}









